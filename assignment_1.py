# -*- coding: utf-8 -*-
"""Copy of Assignment-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1umVz2P9ccKjbQyDKCqgZbuKzCsFDXx-1
"""

# Commented out IPython magic to ensure Python compatibility.
import cv2
import os
import sys
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

#from google.colab import drive
#drive.mount('/content/drive')

print('OpenCV-Python Lib Version:', cv2.__version__)
print('Python Version:',sys.version)

def displayImage(image,title):
    plt.imshow(cv2.cvtColor(image,cv2.COLOR_BGR2RGB))
    plt.title(title)
    plt.show()

"""# 2.1 Load the set of images and display them as Grayscale and rgb images. You are required to show these
images ”inline” rather than creating a new window for every other image. (2 points)
"""

img_gray = cv2.imread("Images/01.jpg",0) # 0 for grayscal
print(img_gray.shape)
img_gray2 = cv2.imread("Images/02.jpg",0) # 0 for grayscal
print(img_gray2.shape)
img_gray3 = cv2.imread("Images/03.png",0) # 0 for grayscal
print(img_gray3.shape)
img_gray4 = cv2.imread("Images/04.jpg",0) # 0 for grayscal
print(img_gray4.shape)
img_gray5 = cv2.imread("Images/05.jpeg",0) # 0 for grayscal
print(img_gray5.shape)
img_gray6 = cv2.imread("Images/06.jpeg",0) # 0 for grayscal
print(img_gray6.shape)
img_gray7 = cv2.imread("Images/07.jpg",0) # 0 for grayscal
print(img_gray7.shape)
img_gray8 = cv2.imread("Images/08.jpg",0) # 0 for grayscal
print(img_gray8.shape)




displayImage(img_gray,"Gray")
displayImage(img_gray2,"Gray")
displayImage(img_gray3,"Gray")
displayImage(img_gray4,"Gray")
displayImage(img_gray5,"Gray")
displayImage(img_gray6,"Gray")
displayImage(img_gray7,"Gray")
displayImage(img_gray8,"Gray")



plt.subplot(181),plt.imshow(img_gray,'gray'),plt.title('1')
plt.subplot(182),plt.imshow(img_gray2,'gray'),plt.title('2')
plt.subplot(183),plt.imshow(img_gray3,'gray'),plt.title('3')
plt.subplot(184),plt.imshow(img_gray4,'gray'),plt.title('4')
plt.subplot(185),plt.imshow(img_gray5,'gray'),plt.title('5')
plt.subplot(186),plt.imshow(img_gray6,'gray'),plt.title('6')
plt.subplot(187),plt.imshow(img_gray7,'gray'),plt.title('7')
plt.subplot(188),plt.imshow(img_gray8,'gray'),plt.title('8')

plt.show()

#from google.colab import drive
#drive.mount('/content/drive')

# define a function for concatenating 
# images of different sizes in 
# vertical and horizontal tiles 






#from scipy.misc import face
#import numpy as np
#import matplotlib.pyplot as plt

#img_gray = face("/content/drive/My Drive/Colab Notebooks/Images/01.jpg")
#img_gray2 = face("/content/drive/My Drive/Colab Notebooks/Images/02.jpg")
#img_gray3 = face("/content/drive/My Drive/Colab Notebooks/Images/03.png")
#result = np.vstack((img_gray,img_gray2,img_gray3))
#merge = np.concatenate((img_gray,img_gray2,img_gray3))

#plt.gray()
#plt.imshow(merge)

#cv2_imshow(merge)

"""RGB"""

img_colored = cv2.imread("Images/01.jpg",1) # for colored Image
print(img_colored.shape)
img_colored2 = cv2.imread("Images/02.jpg",1) # for colored Image
print(img_colored2.shape)
img_colored3 = cv2.imread("Images/03.png",1) # for colored Image
print(img_colored3.shape)
img_colored4 = cv2.imread("Images/04.jpg",1) # for colored Image
print(img_colored4.shape)
img_colored5 = cv2.imread("Images/05.jpeg",1) # for colored Image
print(img_colored5.shape)
img_colored6 = cv2.imread("Images/06.jpeg",1) # for colored Image
print(img_colored6.shape)
img_colored7 = cv2.imread("Images/07.jpg",1) # for colored Image
print(img_colored7.shape)
img_colored8 = cv2.imread("Images/08.jpg",1) # for colored Image
print(img_colored8.shape)

displayImage(img_colored,"Colored Image")
displayImage(img_colored2,"Colored Image")
displayImage(img_colored3,"Colored Image")
displayImage(img_colored4,"Colored Image")
displayImage(img_colored5,"Colored Image")
displayImage(img_colored6,"Colored Image")
displayImage(img_colored7,"Colored Image")
displayImage(img_colored8,"Colored Image")



"""# 2.2 Implement the function rgbExclusion() in the helper script, in which the input image is decomposed
into the three channels: R, G and B and return the image excluding the specified channel. Display
the results in notebook. (3 points)
"""

bgr_image = img_colored.copy()
bgr_image2 = img_colored.copy()
bgr_image3 = img_colored.copy()


bgr_image[:,:,0] = 0 #empty blue channel
bgr_image[:,:,1] = 0 #empty green channel
bgr_image2[:,:,0] = 0 #empty blue channel
bgr_image2[:,:,2] = 0 #empty red channel
bgr_image3[:,:,1] = 0 #empty green channel
bgr_image3[:,:,2] = 0 #empty red channel

# and we are left out with red channel
displayImage(bgr_image,"Red Channel")
displayImage(bgr_image2,"Green Channel")
displayImage(bgr_image3,"Blue Channel")

"""# 2.3 Take at-least 3 images from given set and plot histograms before and after applying histogram equalization.
Show these image inline format i.e. grayscale image –> display histogram –> apply histogram
equalization–> display the equalized image and its histogram. (5 points)
"""

img = cv2.imread("Images/01.jpg",0)
img2 = cv2.imread("Images/02.jpg",0)
img3 = cv2.imread("Images/03.png",0)


plt.hist(img.ravel(),256,[0,256])
plt.title('First Image')
plt.show()


equ = cv2.equalizeHist(img) 
  
# stacking images side-by-side 
res = np.hstack((img, equ)) 
displayImage(res,"Grayscale | Equalized")



plt.hist(equ.ravel(),256,[0,256])
plt.hist(img.ravel(),256,[0,256])
plt.title('Before and After')
plt.show()


#SECOND IMAGE
plt.hist(img2.ravel(),256,[0,256])
plt.title('Second Image')
plt.show()


equ = cv2.equalizeHist(img2) 
  
# stacking images side-by-side 
res = np.hstack((img2, equ)) 
displayImage(res,"Grayscale | Equalized")



plt.hist(equ.ravel(),256,[0,256])
plt.hist(img2.ravel(),256,[0,256])
plt.title('Before and After')
plt.show()


#THIRD IMAGE
plt.hist(img3.ravel(),256,[0,256])
plt.title('Third Image')
plt.show()


equ = cv2.equalizeHist(img3) 
  
# stacking images side-by-side 
res = np.hstack((img3, equ)) 
displayImage(res,"Grayscale | Equalized")



plt.hist(equ.ravel(),256,[0,256])
plt.hist(img3.ravel(),256,[0,256])
plt.title('Before and After')
plt.show()



"""# 2.4 You are required to implement the convolution operation from scratch. This function which takes an
image and a kernel and returns the convolution of them.
Compare the results of your implemented function with the ones available (built-in) in python
packages. You are required to convolve images for sharpening and blurring effects. (5 points)
"""

#import cv2
#import numpy as np
#from matplotlib import pyplot as plt

#img = cv2.imread('/content/drive/My Drive/Colab Notebooks/Images/05.jpeg')

#blur = cv2.blur(img,(5,5))

#plt.subplot(121),plt.imshow(img),plt.title('Original')
#plt.xticks([]), plt.yticks([])
#plt.subplot(122),plt.imshow(blur),plt.title('Blurred')
#plt.xticks([]), plt.yticks([])
#plt.show()



import cv2
import os
import sys
from skimage import io
import numpy as np
import matplotlib.pyplot as plt

def myConvolve2d(image, kernel):
    """
    In this function convolution operation is implemented from scratch
    # This function which takes an image and a kernel 
    # and returns the convolution of them
    # Args:
    #   image: a numpy array of size [image_height, image_width].
    #   kernel: a numpy array of size [kernel_height, kernel_width].
    # Returns:
    #   a numpy array of size [image_height, image_width] (convolution output).
    
    """
    kernel = np.flipud(np.fliplr(kernel))    # Flip the kernel
    output = np.zeros_like(image)            # convolution output
    # Add zero padding to the input image
    image_padded = np.zeros((image.shape[0] + 2, image.shape[1] + 2))   
    image_padded[1:-1, 1:-1] = image
    
    # Loop over every pixel of the image and implement convolution operation (element wise multiplication and summation). 
    # You can use two loops. The result is stored in the variable output.
    
    for x in range(image.shape[0]):     # Loop over every pixel of the image
        for y in range(image.shape[1]):
            # element-wise multiplication and summation 
            output[x,y]=(kernel*image_padded[x:x+3,y:y+3]).sum()
        
    
    return output

img = io.imread("Images/07.jpg",1) #in skimage 1 is for grayscale 
plt.imshow(img,cmap=plt.cm.gray)

# Convolve the sharpen kernel (laplacian) and the image
kernel = np.array([[0,-1,0],[-1,5,-1],[0,-1,0]])
#Call the function my_convolve2d
image_sharpen = myConvolve2d(img,kernel)
plt.imshow(image_sharpen,cmap=plt.cm.gray)

from skimage import exposure
# Adjust the contrast of the filtered image by applying Histogram Equalization 
image_sharpen_equalized = exposure.equalize_adapthist(image_sharpen/np.max(np.abs(image_sharpen)), clip_limit=0.03)
plt.imshow(image_sharpen_equalized,cmap=plt.cm.gray)

from scipy import signal
f = signal.convolve2d(img,kernel, 'same')
plt.imshow(f,cmap=plt.cm.gray)





img = cv2.imread("Images/07.jpg",0)

kernel = np.ones((3,3),np.float32)/9 #blur
f = signal.convolve2d(img,kernel, 'same')

plt.rcParams['figure.figsize'] = (20.0, 16.0) # set default size of plots
fig = plt.figure()
fig.add_subplot(3, 3, 1)
plt.imshow(img,cmap=plt.cm.gray)
plt.title("GrayScale")
fig.add_subplot(3, 3, 2)
plt.imshow(f,cmap=plt.cm.gray)
plt.title("Blurred")



img = cv2.imread("Images/08.jpg",0)

kernel = np.ones((5,5),np.float32)/25 #blur
f = signal.convolve2d(img,kernel, 'same')

plt.rcParams['figure.figsize'] = (20.0, 16.0) # set default size of plots
fig = plt.figure()
fig.add_subplot(3, 3, 1)
plt.imshow(img,cmap=plt.cm.gray)
plt.title("GrayScale")
fig.add_subplot(3, 3, 2)
plt.imshow(f,cmap=plt.cm.gray)
plt.title("Blurred")

"""# 2.5 Load a couple of images from the given set.
1. Apply box filter using convolution, and display the resultant image
2. Apply Gaussian filter to the image, with varying sigma values.
"""

img_gaussianFilter = cv2.GaussianBlur(img, (5,5),sigmaX=4)
fig = plt.figure()
fig.add_subplot(2, 2, 1)
plt.imshow(img,cmap=plt.cm.gray)
plt.title("Original")
fig.add_subplot(2, 2, 2)
plt.imshow(img_gaussianFilter,cmap=plt.cm.gray)
plt.title("Gaussian Filter, sigma=4")
fig.add_subplot(2, 2, 3)
img_gaussianFilter = cv2.GaussianBlur(img, (5,5),sigmaX=5)
plt.imshow(img_gaussianFilter,cmap=plt.cm.gray)
plt.title("Gaussian Filter, sigma=4")
img_gaussianFilter = cv2.GaussianBlur(img, (5,5),sigmaX=6)
fig.add_subplot(2, 2, 4)
plt.imshow(img_gaussianFilter,cmap=plt.cm.gray)
plt.title("Gaussian Filter, sigma=5")

"""3. Add Gausian Noise and Salt and Pepper Noise to them."""

import skimage
import matplotlib.pyplot as plt
img_path="Images/08.jpg"
img = skimage.io.imread(img_path)/255.0

def plotnoise(img, mode, r, c, i):
    plt.subplot(r,c,i)
    if mode is not None:
        gimg = skimage.util.random_noise(img, mode=mode)
        plt.imshow(gimg)
    else:
        plt.imshow(img)
    plt.title(mode)
    plt.axis("off")

plt.figure(figsize=(18,24))
r=4
c=2
plotnoise(img, "gaussian", r,c,1)
plotnoise(img, "s&p", r,c,2)
#plotnoise(img, None, r,c,3)
plt.show()

"""# 4. Apply Gaussian Filter and Median Filters."""

img_gaussianFilter = cv2.GaussianBlur(img, (5,5),sigmaX=4)
fig = plt.figure()
fig.add_subplot(1, 2, 1)
plt.imshow(img,cmap=plt.cm.gray)
plt.title("Original")
fig.add_subplot(1, 2, 2)
plt.imshow(img_gaussianFilter,cmap=plt.cm.gray)
plt.title("Gaussian Filter, sigma=4")

#Median filter
#img_med = cv2.medianBlur(img,5)

#img_med = cv2.medianBlur(img,5)

#fig = plt.figure()
#fig.add_subplot(1, 2, 1)
#plt.imshow(img,cmap=plt.cm.gray)
#plt.title("Original")
#fig.add_subplot(1, 2, 2)
#plt.imshow(img_med,cmap=plt.cm.gray)
#plt.title("Median Filter")

#cv2.medianBlur(input_image, kernel_size)

import cv2
import numpy as np
from skimage.util import random_noise
 
# Load an image
#im_arr = cv2.imread("D:/downloads/opencv_logo.PNG")
im_arr = img 
# Add salt and pepper noise to the image
noise_img = random_noise(im_arr, mode="s&p",amount=0.3)
noise_img = np.array(255*noise_img, dtype = 'uint8')
 
# Apply median filter
median = cv2.medianBlur(noise_img,5)
 
# Display the image
plt.imshow(noise_img)
plt.title("Median Filter")
plt.imshow(median)
plt.title("Median Filter1")



#from matplotlib.pyplot import figure, imshow, axis
#from matplotlib.image import imread

#def showImagesHorizontally(list_of_files):
 #   fig = figure()
  #  number_of_files = len(list_of_files)
   # for i in range(number_of_files):
    #    a=fig.add_subplot(1,number_of_files,i+1)
     #   image = imread(list_of_files[i])
      #  imshow(image,cmap='Greys_r')
       # axis('off')

#import matplotlib.pyplot as plt
#f,ax = plt.subplots(1,5)
#for i in range(5):
 #   ax[i].imshow(img)
#plt.show() # or display.display(plt.gcf()) if you prefer





#import cv2
#import numpy as np
#from matplotlib import pyplot as plt

#BLUE = [255,0,0]

#img1 = cv2.imread('opencv_logo.png')

#replicate = cv2.copyMakeBorder(img1,10,10,10,10,cv2.BORDER_REPLICATE)
#reflect = cv2.copyMakeBorder(img1,10,10,10,10,cv2.BORDER_REFLECT)
#reflect101 = cv2.copyMakeBorder(img1,10,10,10,10,cv2.BORDER_REFLECT_101)
#wrap = cv2.copyMakeBorder(img1,10,10,10,10,cv2.BORDER_WRAP)
#constant= cv2.copyMakeBorder(img1,10,10,10,10,cv2.BORDER_CONSTANT,value=BLUE)

#plt.subplot(231),plt.imshow(img1,'gray'),plt.title('ORIGINAL')
#plt.subplot(232),plt.imshow(replicate,'gray'),plt.title('REPLICATE')
#plt.subplot(233),plt.imshow(reflect,'gray'),plt.title('REFLECT')
#plt.subplot(234),plt.imshow(reflect101,'gray'),plt.title('REFLECT_101')
#lt.subplot(235),plt.imshow(wrap,'gray'),plt.title('WRAP')
#plt.subplot(236),plt.imshow(constant,'gray'),plt.title('CONSTANT')

#plt.show()





"""# 5: Display mesh plots for different i) Gaussian filters, ii) First Order Derivative of Gaussian, iii) Laplacian of Gaussian; using different sigma values

**Guassian**
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import cv2

# generate some sample data
import scipy.misc
#lena = cv2.imread("/content/drive/My Drive/Colab Notebooks/Images/07.jpg", 0)
# downscaling has a "smoothing" effect
#lena = cv2.resize(lena, (100,100))
# create the x and y coordinate arrays (here we just use pixel indices)
#xx, yy = np.mgrid[0:lena.shape[0], 0:lena.shape[1]]
# create the figure
#fig = plt.figure()
#ax = fig.gca(projection='3d')
#ax.plot_surface(xx, yy, lena ,rstride=1, cstride=1, cmap=plt.cm.jet,
#                linewidth=0)
# show it
#plt.show()
 

# downscaling has a "smoothing" effect
img_gaussianFilter = cv2.resize(img_gaussianFilter, (100,100))
 

# create the x and y coordinate arrays (here we just use pixel indices)
xx, yy = np.mgrid[0:img_gaussianFilter.shape[0], 0:img_gaussianFilter.shape[1]]
 

# create the figure
fig = plt.figure()
ax = fig.gca(projection='3d')
ax.plot_surface(xx, yy, img_gaussianFilter ,rstride=1, cstride=1, cmap=plt.cm.jet,
                linewidth=0)


# show it
plt.show()


#image_first_derivative



"""**First Order Derivate**"""

from scipy.ndimage import gaussian_filter
image = cv2.imread("Images/02.jpg",0)

image_first_derivative = gaussian_filter(image, sigma=3)
plt.imshow(image_first_derivative)

#image_first_derivative

image_first_derivative = cv2.resize(image_first_derivative, (100,100))
 

# create the x and y coordinate arrays (here we just use pixel indices)
xx, yy = np.mgrid[0:image_first_derivative.shape[0], 0:image_first_derivative.shape[1]]
 

# create the figure
fig = plt.figure()
ax = fig.gca(projection='3d')
ax.plot_surface(xx, yy, image_first_derivative ,rstride=1, cstride=1, cmap=plt.cm.jet,                linewidth=0)


# show it
plt.show()



"""**Laplacian**"""

import cv2
import numpy as np
from matplotlib import pyplot as plt

# loading image
#img0 = cv2.imread('SanFrancisco.jpg',)
img0 = cv2.imread('Images/02.jpg',)

# converting to gray scale
gray = cv2.cvtColor(img0, cv2.COLOR_BGR2GRAY)

# remove noise
img = cv2.GaussianBlur(gray,(3,3),0)

# convolute with proper kernels
laplacian = cv2.Laplacian(img,cv2.CV_64F)
sobelx = cv2.Sobel(img,cv2.CV_64F,1,0,ksize=5)  # x
sobely = cv2.Sobel(img,cv2.CV_64F,0,1,ksize=5)  # y

plt.subplot(2,2,1),plt.imshow(img0)
plt.title('Original'), plt.xticks([]), plt.yticks([])
plt.subplot(2,2,2),plt.imshow(laplacian,cmap = 'gray')
plt.title('Laplacian'), plt.xticks([]), plt.yticks([])
#plt.subplot(2,2,3),plt.imshow(sobelx,cmap = 'gray')
#plt.title('Sobel X'), plt.xticks([]), plt.yticks([])
#plt.subplot(2,2,4),plt.imshow(sobely,cmap = 'gray')
#plt.title('Sobel Y'), plt.xticks([]), plt.yticks([])

plt.show()


laplacian = cv2.resize(laplacian, (100,100))
 

# create the x and y coordinate arrays (here we just use pixel indices)
xx, yy = np.mgrid[0:laplacian.shape[0], 0:laplacian.shape[1]]
 

# create the figure
fig = plt.figure()
ax = fig.gca(projection='3d')
ax.plot_surface(xx, yy, laplacian ,rstride=1, cstride=1, cmap=plt.cm.jet,                linewidth=0)


# show it
plt.show()













"""Load a few images from the given set.
# 1. Apply Sobel operator, computer gradient magnitude and display the results (original image, gradient
images and gradient magnitude image).
"""

import cv2
import numpy as np
from matplotlib import pyplot as plt

# loading image
#img0 = cv2.imread('SanFrancisco.jpg',)
img0 = cv2.imread('Images/02.jpg',)

# converting to gray scale
gray = cv2.cvtColor(img0, cv2.COLOR_BGR2GRAY)

# remove noise
img = cv2.GaussianBlur(gray,(3,3),0)

# convolute with proper kernels
laplacian = cv2.Laplacian(img,cv2.CV_64F)
sobelx = cv2.Sobel(img,cv2.CV_64F,1,0,ksize=5)  # x
sobely = cv2.Sobel(img,cv2.CV_64F,0,1,ksize=5)  # y

plt.subplot(2,2,1),plt.imshow(img0)
plt.title('Original'), plt.xticks([]), plt.yticks([])
#plt.subplot(2,2,2),plt.imshow(laplacian,cmap = 'gray')
#plt.title('Laplacian'), plt.xticks([]), plt.yticks([])
plt.subplot(2,2,2),plt.imshow(sobelx,cmap = 'gray')
plt.title('Sobel X'), plt.xticks([]), plt.yticks([])
plt.subplot(2,2,3),plt.imshow(sobely,cmap = 'gray')
plt.title('Sobel Y'), plt.xticks([]), plt.yticks([])

plt.show()

"""# 2. Apply Laplacian of Gaussian, computer laplacian magnitude and display the results (original image,
filtered images and laplacian magnitude image). Try different filter kernel coefficients.
"""

import cv2
import numpy as np
from matplotlib import pyplot as plt

# loading image
#img0 = cv2.imread('SanFrancisco.jpg',)
img0 = cv2.imread('Images/02.jpg',)

# converting to gray scale
gray = cv2.cvtColor(img0, cv2.COLOR_BGR2GRAY)

# remove noise
img = cv2.GaussianBlur(gray,(3,3),0)

# convolute with proper kernels
laplacian = cv2.Laplacian(img,cv2.CV_64F)
sobelx = cv2.Sobel(img,cv2.CV_64F,1,0,ksize=5)  # x
sobely = cv2.Sobel(img,cv2.CV_64F,0,1,ksize=5)  # y

plt.subplot(2,2,1),plt.imshow(img0)
plt.title('Original'), plt.xticks([]), plt.yticks([])
plt.subplot(2,2,2),plt.imshow(laplacian,cmap = 'gray')
plt.title('Laplacian'), plt.xticks([]), plt.yticks([])
#plt.subplot(2,2,3),plt.imshow(sobelx,cmap = 'gray')
#plt.title('Sobel X'), plt.xticks([]), plt.yticks([])
#plt.subplot(2,2,4),plt.imshow(sobely,cmap = 'gray')
#plt.title('Sobel Y'), plt.xticks([]), plt.yticks([])

plt.show()



"""# 3. Apply Canny Edge Detector and display the results."""

#canny edge
img = cv2.imread("Images/03.png",0)
edges = cv2.Canny(img, 100, 200)
plt.rcParams['figure.figsize'] = (20.0, 16.0) # set default size of plots
fig = plt.figure()
fig.add_subplot(1, 3, 1)
plt.imshow(img,cmap=plt.cm.gray)
plt.title("GrayScale")
fig.add_subplot(1, 3, 2).imshow(edges,cmap=plt.cm.gray)
plt.title("Canny edge detector")



"""# 2.7 Bonus Marks
(5 points) Implement Canny Edge detector from scratch or use built-in function from python packages,
and apply it on a real time video/stream.
"""

